android通过JNI访问底层硬件的实现方法

1.在上层定义native函数
public class Native{
    static{
        System.loadLibrary("native");//调用.so文件,一般生成的.so文件的全名为：lib***.so,我们在调用的时候一般只取***部分,把前面的lib和后面的.so去掉
    }
    
    public static native String native_method_a(String str);
    public static native int native_method_b(int b);
    public static native void native_method_c();
}

2.在上层调用native函数
public class Test{
    
    public String get_a(String str){
        return Native.native_method_a(str);
    }
    
    public int get_b(int b){
        return Native.native_method_b(b);
    }
    
    public void get_c{
        Native.native_method_c();
    }
    
}

3.编译产生Native.class二进制文件,用javah命令生成.h文件(在工程根目录下执行)
  javah -classpath bin/classes -d jni com.unistrong.test.Native
  
  说明: -classpath     表示class文件在某个目录中
        bin/classes    表示Test.class所在的目录
        -d jni         在jni目录中生成.h文件,如果没有jni目录,则创建jni目录
                       最后的参数表示你的class文件
   
   执行后,在jni目录下将会生成com.unistrong.test.Native.h文件,该文件的内容如下:
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_unistrong_test_Native */

#ifndef _Included_com_unistrong_test_Native
#define _Included_com_unistrong_test_Native
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_unistrong_test_Native
 * Method:    initUart
 * Signature: V
 */
JNIEXPORT void JNICALL Java_com_unistrong_test_Native_get_c
  (JNIEnv *, jclass);

/*
 * Class:     com_unistrong_test_Native
 * Method:    exit
 * Signature: (I)V
 */
JNIEXPORT int JNICALL Java_com_unistrong_test_Native_get_b
  (JNIEnv *, jclass, jint);

/*
 * Class:     com_unistrong_test_Native
 * Method:    get
 * Signature: (I)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_unistrong_test_Native_get_a
  (JNIEnv *, jclass, jstring);

#ifdef __cplusplus
}
#endif
#endif


4.实现.c文件  com.unistrong.test.Test.c
  
  #include "com.unistrong.test.Test.h"
  #include <stdio.h>

JNIEXPORT void JNICALL Java_com_unistrong_test_Native_get_c
  (JNIEnv *env, jclass cls){
      printf("get_c");
      //打开串口等相关操作
  }


JNIEXPORT int JNICALL Java_com_unistrong_test_Native_get_b
  (JNIEnv *env, jclass cls, jint b){
      jint c = b * b;
      //操作硬件
      return c;
  }


JNIEXPORT jstring JNICALL Java_com_unistrong_test_Native_get_a
  (JNIEnv *env, jclass cls, jstring str){
      //操作硬件
      return (*env)->NewStringUTF(env, "Hello Native");
  }
  
5.生成.so(这里不介绍NDK的方式,如果用NDK,可以去找NDK的教程.)
  在external目录下新建一个文件夹jnitest,把***.h和***.c两个文件拷贝到/external/jnitest目录下。
  
6.编写.mk文件,Android.mk
############################################################
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := jnitest

# This is the target being built.
#编译的目标对象,就是生成的libnative.so的名称
LOCAL_MODULE:= libnative


# All of the source files that we will compile.
# 编译的源文件
LOCAL_SRC_FILES:= \
  com_unistrong_test_Native.c

# All of the shared libraries we link against.
#连接时需要的外部库
LOCAL_SHARED_LIBRARIES := \
	libutils

# No static libraries.
#不需要静态链接库
LOCAL_STATIC_LIBRARIES :=

# Also need the JNI headers.
#需要包含的头文件目录
LOCAL_C_INCLUDES += \
	$(JNI_H_INCLUDE)

# No special compiler flags.
LOCAL_CFLAGS +=

# Don't prelink this library.  For more efficient code, you may want
# to add this library to the prelink map and set this to true. However,
# it's difficult to do this for applications that are not supplied as
# part of a system image.
#是否需要prelink处理
LOCAL_PRELINK_MODULE := false

include $(BUILD_SHARED_LIBRARY)
############################################################

7.执行make jnitest
  如果没有任何错误的话,编译结果会告诉你这个：
  target Non-prelinked: libbarcodejni (out/target/product/generic/symbols/system/lib/libnative.so)
  这就是我们生成的.so文件所在的目录
  将这个.so文件拷贝到(out/target/product/你的产品名称(如:smdkc110)/system/lib/)
  cp out/target/product/generic/symbols/system/lib/libnative.so  out/target/product/smdkc110/system/lib/
  
8.编译整个系统即可.代码可以参考E7702-GB的BarcodeTest工程
  